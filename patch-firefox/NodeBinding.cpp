/* THIS FILE IS AUTOGENERATED FROM Node.webidl BY Codegen.py - DO NOT EDIT */

#include "EventTargetBinding.h"
#include "NodeBinding.h"
#include "WrapperFactory.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/Element.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "nsContentUtils.h"
#include "nsDOMMutationObserver.h"
#include "nsIDocument.h"
#include "nsINode.h"
#include "nsINodeList.h"
#include "nsIPrincipal.h"
#include "nsIURI.h"
#include "contfetcher.h"

namespace mozilla {
namespace dom {

namespace NodeBinding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<EventTargetBinding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

static bool
get_nodeType(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  uint16_t result(self->NodeType());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo nodeType_getterinfo = {
  { (JSJitGetterOp)get_nodeType },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_nodeName(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  DOMString result;
  self->GetNodeName(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo nodeName_getterinfo = {
  { (JSJitGetterOp)get_nodeName },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_baseURI(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  DOMString result;
  self->GetBaseURIFromJS(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo baseURI_getterinfo = {
  { (JSJitGetterOp)get_baseURI },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_ownerDocument(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsIDocument>(self->GetOwnerDocument()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo ownerDocument_getterinfo = {
  { (JSJitGetterOp)get_ownerDocument },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_rootNode(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINode>(self->RootNode()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo rootNode_getterinfo = {
  { (JSJitGetterOp)get_rootNode },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_parentNode(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINode>(self->GetParentNode()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo parentNode_getterinfo = {
  { (JSJitGetterOp)get_parentNode },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_parentElement(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<mozilla::dom::Element>(self->GetParentElement()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo parentElement_getterinfo = {
  { (JSJitGetterOp)get_parentElement },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
hasChildNodes(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  bool result(self->HasChildNodes());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo::ArgType hasChildNodes_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo hasChildNodes_methodinfo = {
  {
    { (JSJitGetterOp)hasChildNodes },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  hasChildNodes_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_childNodes(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINodeList>(self->ChildNodes()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo childNodes_getterinfo = {
  { (JSJitGetterOp)get_childNodes },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_firstChild(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINode>(self->GetFirstChild()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo firstChild_getterinfo = {
  { (JSJitGetterOp)get_firstChild },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_lastChild(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINode>(self->GetLastChild()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo lastChild_getterinfo = {
  { (JSJitGetterOp)get_lastChild },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_previousSibling(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINode>(self->GetPreviousSibling()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo previousSibling_getterinfo = {
  { (JSJitGetterOp)get_previousSibling },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_nextSibling(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsINode>(self->GetNextSibling()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo nextSibling_getterinfo = {
  { (JSJitGetterOp)get_nextSibling },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_nodeValue(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  DOMString result;
  self->GetNodeValue(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_nodeValue(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitSetterCallArgs args)
{
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetNodeValue(NonNullHelper(Constify(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nodeValue_getterinfo = {
  { (JSJitGetterOp)get_nodeValue },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nodeValue_setterinfo = {
  { (JSJitGetterOp)set_nodeValue },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_textContent(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  ErrorResult rv;
  DOMString result;
  self->GetTextContent(result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_textContent(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitSetterCallArgs args)
{
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  ErrorResult rv;
  self->SetTextContent(NonNullHelper(Constify(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo textContent_getterinfo = {
  { (JSJitGetterOp)get_textContent },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo textContent_setterinfo = {
  { (JSJitGetterOp)set_textContent },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
insertBefore(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.insertBefore");
  }
  NonNull<nsINode> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.insertBefore", "Node");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.insertBefore");
    return false;
  }
  nsINode* arg1;
  if (args[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 2 of Node.insertBefore", "Node");
        return false;
      }
    }
  } else if (args[1].isNullOrUndefined()) {
    arg1 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of Node.insertBefore");
    return false;
  }
  ErrorResult rv;
  CONTFETCHER_PREVENT_ATTRIB(&NonNullHelper(arg0));
  auto result(StrongOrRawPtr<nsINode>(self->InsertBefore(NonNullHelper(arg0), Constify(arg1), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo insertBefore_methodinfo = {
  { (JSJitGetterOp)insertBefore },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
appendChild(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.appendChild");
  }
  NonNull<nsINode> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.appendChild", "Node");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.appendChild");
    return false;
  }
  ErrorResult rv;
  CONTFETCHER_PREVENT_ATTRIB(&NonNullHelper(arg0));
  auto result(StrongOrRawPtr<nsINode>(self->AppendChild(NonNullHelper(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo appendChild_methodinfo = {
  { (JSJitGetterOp)appendChild },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
replaceChild(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.replaceChild");
  }
  NonNull<nsINode> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.replaceChild", "Node");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.replaceChild");
    return false;
  }
  NonNull<nsINode> arg1;
  if (args[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[1].toObject(), arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 2 of Node.replaceChild", "Node");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of Node.replaceChild");
    return false;
  }
  ErrorResult rv;
  CONTFETCHER_PREVENT_ATTRIB(&NonNullHelper(arg0));
  auto result(StrongOrRawPtr<nsINode>(self->ReplaceChild(NonNullHelper(arg0), NonNullHelper(arg1), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo replaceChild_methodinfo = {
  { (JSJitGetterOp)replaceChild },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
removeChild(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.removeChild");
  }
  NonNull<nsINode> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.removeChild", "Node");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.removeChild");
    return false;
  }
  ErrorResult rv;
  CONTFETCHER_PREVENT_ATTRIB(&NonNullHelper(arg0));
  auto result(StrongOrRawPtr<nsINode>(self->RemoveChild(NonNullHelper(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo removeChild_methodinfo = {
  { (JSJitGetterOp)removeChild },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
normalize(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  self->Normalize();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo normalize_methodinfo = {
  { (JSJitGetterOp)normalize },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
cloneNode(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  bool arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[0], &arg0)) {
      return false;
    }
  } else {
    arg0 = false;
  }
  ErrorResult rv;
  auto result(StrongOrRawPtr<nsINode>(self->CloneNode(arg0, rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo cloneNode_methodinfo = {
  { (JSJitGetterOp)cloneNode },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
isSameNode(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.isSameNode");
  }
  nsINode* arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.isSameNode", "Node");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.isSameNode");
    return false;
  }
  bool result(self->IsSameNode(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo::ArgType isSameNode_methodinfo_argTypes[] = { JSJitInfo::ArgType(JSJitInfo::Null | JSJitInfo::Object), JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo isSameNode_methodinfo = {
  {
    { (JSJitGetterOp)isSameNode },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  isSameNode_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
isEqualNode(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.isEqualNode");
  }
  nsINode* arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.isEqualNode", "Node");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.isEqualNode");
    return false;
  }
  bool result(self->IsEqualNode(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo::ArgType isEqualNode_methodinfo_argTypes[] = { JSJitInfo::ArgType(JSJitInfo::Null | JSJitInfo::Object), JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo isEqualNode_methodinfo = {
  {
    { (JSJitGetterOp)isEqualNode },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  isEqualNode_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
compareDocumentPosition(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.compareDocumentPosition");
  }
  NonNull<nsINode> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.compareDocumentPosition", "Node");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.compareDocumentPosition");
    return false;
  }
  uint16_t result(self->CompareDocumentPosition(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType compareDocumentPosition_methodinfo_argTypes[] = { JSJitInfo::Object, JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo compareDocumentPosition_methodinfo = {
  {
    { (JSJitGetterOp)compareDocumentPosition },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  compareDocumentPosition_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
contains(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.contains");
  }
  nsINode* arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::Node, nsINode>(&args[0].toObject(), arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of Node.contains", "Node");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of Node.contains");
    return false;
  }
  bool result(self->Contains(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo::ArgType contains_methodinfo_argTypes[] = { JSJitInfo::ArgType(JSJitInfo::Null | JSJitInfo::Object), JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo contains_methodinfo = {
  {
    { (JSJitGetterOp)contains },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  contains_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
lookupPrefix(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.lookupPrefix");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  DOMString result;
  self->LookupPrefix(NonNullHelper(Constify(arg0)), result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo::ArgType lookupPrefix_methodinfo_argTypes[] = { JSJitInfo::ArgType(JSJitInfo::Null | JSJitInfo::String), JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo lookupPrefix_methodinfo = {
  {
    { (JSJitGetterOp)lookupPrefix },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  lookupPrefix_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
lookupNamespaceURI(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.lookupNamespaceURI");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  DOMString result;
  self->LookupNamespaceURI(NonNullHelper(Constify(arg0)), result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo::ArgType lookupNamespaceURI_methodinfo_argTypes[] = { JSJitInfo::ArgType(JSJitInfo::Null | JSJitInfo::String), JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo lookupNamespaceURI_methodinfo = {
  {
    { (JSJitGetterOp)lookupNamespaceURI },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  lookupNamespaceURI_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
isDefaultNamespace(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.isDefaultNamespace");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  bool result(self->IsDefaultNamespace(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo::ArgType isDefaultNamespace_methodinfo_argTypes[] = { JSJitInfo::ArgType(JSJitInfo::Null | JSJitInfo::String), JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo isDefaultNamespace_methodinfo = {
  {
    { (JSJitGetterOp)isDefaultNamespace },
    { prototypes::id::Node },
    { PrototypeTraits<prototypes::id::Node>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  isDefaultNamespace_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
setUserData(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.setUserData");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  JS::Rooted<JS::Value> arg1(cx);
  arg1 = args[1];
  ErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->SetUserData(cx, NonNullHelper(Constify(arg0)), arg1, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo setUserData_methodinfo = {
  { (JSJitGetterOp)setUserData },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getUserData(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "Node.getUserData");
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  ErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  self->GetUserData(cx, NonNullHelper(Constify(arg0)), &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo getUserData_methodinfo = {
  { (JSJitGetterOp)getUserData },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_nodePrincipal(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsIPrincipal>(self->NodePrincipal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, &NS_GET_IID(nsIPrincipal), args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo nodePrincipal_getterinfo = {
  { (JSJitGetterOp)get_nodePrincipal },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_baseURIObject(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, JSJitGetterCallArgs args)
{
  auto result(StrongOrRawPtr<nsIURI>(self->GetBaseURIObject()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, &NS_GET_IID(nsIURI), args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo baseURIObject_getterinfo = {
  { (JSJitGetterOp)get_baseURIObject },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getBoundMutationObservers(JSContext* cx, JS::Handle<JSObject*> obj, nsINode* self, const JSJitMethodCallArgs& args)
{
  nsTArray<StrongPtrForMember<nsDOMMutationObserver>::Type> result;
  self->GetBoundMutationObservers(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx24 = 0; sequenceIdx24 < length; ++sequenceIdx24) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx24], &tmp)) {
          MOZ_ASSERT(true || JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx24, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo getBoundMutationObservers_methodinfo = {
  { (JSJitGetterOp)getBoundMutationObservers },
  { prototypes::id::Node },
  { PrototypeTraits<prototypes::id::Node>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("hasChildNodes", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&hasChildNodes_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("insertBefore", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&insertBefore_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("appendChild", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&appendChild_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("replaceChild", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&replaceChild_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("removeChild", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&removeChild_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("normalize", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&normalize_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("cloneNode", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&cloneNode_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isSameNode", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&isSameNode_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isEqualNode", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&isEqualNode_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("compareDocumentPosition", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&compareDocumentPosition_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("contains", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&contains_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("lookupPrefix", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&lookupPrefix_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("lookupNamespaceURI", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&lookupNamespaceURI_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isDefaultNamespace", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&isDefaultNamespace_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("setUserData", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&setUserData_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getUserData", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getUserData_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static PrefableDisablers sMethods_disablers15 = {
  true, 0, &IsChromeOrXBL, nullptr, nullptr, nullptr
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { &sMethods_disablers15, &sMethods_specs[15] },
  { nullptr, nullptr }
};

static jsid sMethods_ids[18];

static const JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNSPEC("getBoundMutationObservers", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getBoundMutationObservers_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sChromeMethods[] = {
  { nullptr, &sChromeMethods_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeMethods_ids[2];

static const JSPropertySpec sAttributes_specs[] = {
  { "nodeType", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &nodeType_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "nodeName", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &nodeName_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "baseURI", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &baseURI_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "ownerDocument", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &ownerDocument_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  JS_PS_END,
  { "rootNode", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &rootNode_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  JS_PS_END,
  { "parentNode", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &parentNode_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "parentElement", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &parentElement_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "childNodes", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &childNodes_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "firstChild", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &firstChild_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "lastChild", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &lastChild_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "previousSibling", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &previousSibling_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "nextSibling", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &nextSibling_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "nodeValue", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &nodeValue_getterinfo } }, { { GenericBindingSetter, &nodeValue_setterinfo } }},
  { "textContent", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &textContent_getterinfo } }, { { GenericBindingSetter, &textContent_setterinfo } }},
  JS_PS_END
};

static PrefableDisablers sAttributes_disablers5 = {
  true, 0, nullptr, nullptr, nullptr, nullptr
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers5, &sAttributes_specs[5] },
  { nullptr, &sAttributes_specs[7] },
  { nullptr, nullptr }
};

static jsid sAttributes_ids[17];

static const JSPropertySpec sChromeAttributes_specs[] = {
  { "nodePrincipal", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &nodePrincipal_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  { "baseURIObject", JSPROP_SHARED | JSPROP_ENUMERATE, { { GenericBindingGetter, &baseURIObject_getterinfo } }, JSNATIVE_WRAPPER(nullptr)},
  JS_PS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sChromeAttributes[] = {
  { nullptr, &sChromeAttributes_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeAttributes_ids[3];

static const ConstantSpec sConstants_specs[] = {
  { "ELEMENT_NODE", JS::Int32Value(1) },
  { "ATTRIBUTE_NODE", JS::Int32Value(2) },
  { "TEXT_NODE", JS::Int32Value(3) },
  { "CDATA_SECTION_NODE", JS::Int32Value(4) },
  { "ENTITY_REFERENCE_NODE", JS::Int32Value(5) },
  { "ENTITY_NODE", JS::Int32Value(6) },
  { "PROCESSING_INSTRUCTION_NODE", JS::Int32Value(7) },
  { "COMMENT_NODE", JS::Int32Value(8) },
  { "DOCUMENT_NODE", JS::Int32Value(9) },
  { "DOCUMENT_TYPE_NODE", JS::Int32Value(10) },
  { "DOCUMENT_FRAGMENT_NODE", JS::Int32Value(11) },
  { "NOTATION_NODE", JS::Int32Value(12) },
  { "DOCUMENT_POSITION_DISCONNECTED", JS::Int32Value(1) },
  { "DOCUMENT_POSITION_PRECEDING", JS::Int32Value(2) },
  { "DOCUMENT_POSITION_FOLLOWING", JS::Int32Value(4) },
  { "DOCUMENT_POSITION_CONTAINS", JS::Int32Value(8) },
  { "DOCUMENT_POSITION_CONTAINED_BY", JS::Int32Value(16) },
  { "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", JS::Int32Value(32) },
  { 0, JS::UndefinedValue() }
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const ConstantSpec> sConstants[] = {
  { nullptr, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static jsid sConstants_ids[19];


static const NativePropertiesN<3> sNativeProperties = {
  -1,
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  true,  2 /* sConstants */,
  {
    { sMethods, sMethods_ids, sMethods_specs },
    { sAttributes, sAttributes_ids, sAttributes_specs },
    { sConstants, sConstants_ids, sConstants_specs }
  }
};

static const NativePropertiesN<2> sChromeOnlyNativeProperties = {
  -1,
  false, 0,
  false, 0,
  true,  0 /* sChromeMethods */,
  true,  1 /* sChromeAttributes */,
  false, 0,
  false, 0,
  false, 0,
  {
    { sChromeMethods, sChromeMethods_ids, sChromeMethods_specs },
    { sChromeAttributes, sChromeAttributes_ids, sChromeAttributes_specs }
  }
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::Node,
  constructors::id::Node,
  EventTargetBinding::sNativePropertyHooks
} };

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  prototypes::id::Node,
  PrototypeTraits<prototypes::id::Node>::Depth,
  sNativePropertyHooks,
  "function Node() {\n    [native code]\n}",
  EventTargetBinding::GetConstructorObject
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "NodePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  prototypes::id::Node,
  PrototypeTraits<prototypes::id::Node>::Depth,
  sNativePropertyHooks,
  "[object NodePrototype]",
  EventTargetBinding::GetProtoObject
};

JSObject*
DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal)
{
  return GetConstructorObjectHandle(aCx, aGlobal, aDefineOnGlobal);
}

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Handle<JSObject*> parentProto(EventTargetBinding::GetProtoObjectHandle(aCx, aGlobal));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(EventTargetBinding::GetConstructorObjectHandle(aCx, aGlobal));
  if (!constructorProto) {
    return;
  }

  static bool sIdsInited = false;
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sMethods, sMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sChromeAttributes, sChromeAttributes_ids)) {
      return;
    }
    if (!InitIds(aCx, sAttributes, sAttributes_ids)) {
      return;
    }
    if (!InitIds(aCx, sConstants, sConstants_ids)) {
      return;
    }
    sIdsInited = true;
  }

  static bool sPrefCachesInited = false;
  if (!sPrefCachesInited && NS_IsMainThread()) {
    sPrefCachesInited = true;
    Preferences::AddBoolVarCache(&sAttributes[1].disablers->enabled, "dom.node.rootNode.enabled");
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::Node);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::Node);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, nullptr, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nsContentUtils::ThreadsafeIsCallerChrome() ? sChromeOnlyNativeProperties.Upcast() : nullptr,
                              "Node", aDefineOnGlobal,
                              nullptr);
}

JS::Handle<JSObject*>
GetProtoObjectHandle(JSContext* aCx, JS::Handle<JSObject*> aGlobal)
{
  /* Get the interface prototype object for this class.  This will create the
     object as needed. */
  bool aDefineOnGlobal = true;

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(aGlobal);
  if (!protoAndIfaceCache.EntrySlotIfExists(prototypes::id::Node)) {
    CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   */
  return JS::Handle<JSObject*>::fromMarkedLocation(protoAndIfaceCache.EntrySlotMustExist(prototypes::id::Node).address());
}

JSObject*
GetProtoObject(JSContext* aCx, JS::Handle<JSObject*> aGlobal)
{
  return GetProtoObjectHandle(aCx, aGlobal);
}

JS::Handle<JSObject*>
GetConstructorObjectHandle(JSContext* aCx, JS::Handle<JSObject*> aGlobal, bool aDefineOnGlobal)
{
  /* Get the interface object for this class.  This will create the object as
     needed. */

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(aGlobal);
  if (!protoAndIfaceCache.EntrySlotIfExists(constructors::id::Node)) {
    CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   */
  return JS::Handle<JSObject*>::fromMarkedLocation(protoAndIfaceCache.EntrySlotMustExist(constructors::id::Node).address());
}

JSObject*
GetConstructorObject(JSContext* aCx, JS::Handle<JSObject*> aGlobal)
{
  return GetConstructorObjectHandle(aCx, aGlobal);
}

} // namespace NodeBinding



} // namespace dom
} // namespace mozilla
